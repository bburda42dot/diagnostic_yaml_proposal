"""MDD comparison tests: YAML→MDD vs ODX→MDD.

These tests prove that the yaml-to-mdd converter produces IDENTICAL
MDD content compared to the reference MDDs generated from ODX
by odxtools (used in CDA test container).

IMPORTANT: Binary format differences are acceptable, but content must be
EXACTLY THE SAME - same services, same variants, same structure.
CDA interprets both files identically.

Test Strategy:
    1. Load YAML file from golden/
    2. Convert to MDD using yaml-to-mdd
    3. Parse generated MDD with FlatBuffers
    4. Parse reference MDD (from ODX/odxtools)
    5. Compare EXACT content equality
"""

from __future__ import annotations

import lzma
import pytest
from pathlib import Path
from typing import TYPE_CHECKING
from dataclasses import dataclass

from yaml_to_mdd.converters.mdd_writer import convert_yaml_to_mdd
from yaml_to_mdd.proto_generated.file_format_pb2 import MDDFile
from yaml_to_mdd.fbs_generated.dataformat.EcuData import EcuData

if TYPE_CHECKING:
    from yaml_to_mdd.converters.mdd_reader import MDDStructure

# Path to golden test files
GOLDEN_DIR = Path(__file__).parent / "golden"


@dataclass
class VariantInfo:
    """Variant information extracted from MDD."""

    name: str
    service_count: int
    parent_ref_count: int
    is_base: bool
    services: set[str]


@dataclass
class MDDContent:
    """Complete MDD content for comparison."""

    ecu_name: str
    variants: dict[str, VariantInfo]
    all_services: set[str]
    comparams: dict[str, str | None]  # ComParam name -> value


def load_mdd_content(path: Path) -> MDDContent:
    """Load and parse MDD file to extract content for comparison.

    Handles both LZMA-compressed and uncompressed MDD files.
    """
    with open(path, "rb") as f:
        f.read(20)  # Skip magic header
        proto_data = f.read()

    mdd = MDDFile()
    mdd.ParseFromString(proto_data)
    raw_data = mdd.chunks[0].data

    # Try LZMA decompression first (golden files from ODX are compressed)
    # Fall back to raw FlatBuffers data (generated without compression)
    try:
        data = lzma.decompress(raw_data, format=lzma.FORMAT_ALONE)
    except lzma.LZMAError:
        # Not compressed, use raw FlatBuffers data
        data = raw_data

    ecu = EcuData.GetRootAs(data, 0)

    ecu_name = ecu.EcuName().decode() if ecu.EcuName() else ""
    variants = {}
    all_services: set[str] = set()

    for i in range(ecu.VariantsLength()):
        v = ecu.Variants(i)
        dl = v.DiagLayer()
        variant_name = (
            dl.ShortName().decode() if dl and dl.ShortName() else f"variant_{i}"
        )

        services: set[str] = set()
        for j in range(dl.DiagServicesLength() if dl else 0):
            svc = dl.DiagServices(j)
            if svc.DiagComm() and svc.DiagComm().ShortName():
                svc_name = svc.DiagComm().ShortName().decode()
                services.add(svc_name)
                all_services.add(svc_name)

        variants[variant_name] = VariantInfo(
            name=variant_name,
            service_count=dl.DiagServicesLength() if dl else 0,
            parent_ref_count=v.ParentRefsLength(),
            is_base=v.IsBaseVariant(),
            services=services,
        )

    # Extract ComParams from base variant's DiagLayer
    comparams: dict[str, str | None] = {}
    if ecu.VariantsLength() > 0:
        base_dl = ecu.Variants(0).DiagLayer()
        if base_dl:
            for i in range(base_dl.ComParamRefsLength()):
                cpr = base_dl.ComParamRefs(i)
                cp = cpr.ComParam()
                if cp:
                    name = cp.ShortName().decode() if cp.ShortName() else f"param_{i}"
                    sv = cpr.SimpleValue()
                    val = sv.Value().decode() if sv and sv.Value() else None
                    comparams[name] = val

    return MDDContent(
        ecu_name=ecu_name,
        variants=variants,
        all_services=all_services,
        comparams=comparams,
    )


@pytest.fixture
def mdd_reader():
    """Lazily import MDDReader avoiding errors if deps missing."""
    from yaml_to_mdd.converters.mdd_reader import MDDReader

    return MDDReader()


class TestFLXC1000ExactComparison:
    """EXACT comparison tests for FLXC1000 ECU.

    These tests enforce that YAML-generated MDD has IDENTICAL content
    to ODX-generated reference MDD. No more, no less.
    """

    @pytest.fixture
    def yaml_path(self) -> Path:
        """Source YAML file for FLXC1000."""
        yaml_path = GOLDEN_DIR / "FLXC1000_yaml.yaml"
        if not yaml_path.exists():
            pytest.skip(f"YAML file not found: {yaml_path}")
        return yaml_path

    @pytest.fixture
    def reference_path(self) -> Path:
        """Reference MDD from ODX (generated by odxtools)."""
        mdd_path = GOLDEN_DIR / "FLXC1000.mdd"
        if not mdd_path.exists():
            pytest.skip(f"Reference MDD not found: {mdd_path}")
        return mdd_path

    @pytest.fixture
    def generated_path(self, yaml_path: Path, tmp_path: Path) -> Path:
        """Convert YAML to MDD and return path to generated file."""
        output_path = tmp_path / "FLXC1000_generated.mdd"
        convert_yaml_to_mdd(yaml_path, output_path)
        return output_path

    @pytest.fixture
    def generated(self, generated_path: Path) -> MDDContent:
        """Parse generated MDD content."""
        return load_mdd_content(generated_path)

    @pytest.fixture
    def reference(self, reference_path: Path) -> MDDContent:
        """Parse reference MDD content."""
        return load_mdd_content(reference_path)

    def test_ecu_name_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """ECU name must be exactly equal."""
        assert generated.ecu_name == reference.ecu_name, (
            f"ECU name mismatch:\n"
            f"  Generated: '{generated.ecu_name}'\n"
            f"  Reference: '{reference.ecu_name}'"
        )

    def test_variant_names_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """Variant names must be exactly the same set - no more, no less."""
        gen_names = set(generated.variants.keys())
        ref_names = set(reference.variants.keys())

        missing = ref_names - gen_names
        extra = gen_names - ref_names

        assert not missing, f"Missing variants in generated MDD: {sorted(missing)}"
        assert not extra, f"Extra variants in generated MDD: {sorted(extra)}"
        assert gen_names == ref_names, "Variant names must be exactly equal"

    def test_variant_service_counts_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """Each variant must have exactly the same number of services."""
        errors = []
        for variant_name, ref_variant in reference.variants.items():
            gen_variant = generated.variants.get(variant_name)
            if gen_variant is None:
                errors.append(f"  {variant_name}: missing in generated")
            elif gen_variant.service_count != ref_variant.service_count:
                errors.append(
                    f"  {variant_name}: {gen_variant.service_count} services "
                    f"(expected {ref_variant.service_count})"
                )

        assert not errors, "Service count mismatch per variant:\n" + "\n".join(errors)

    def test_base_variant_services_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """Base variant (FLXC1000) must have exactly the same services."""
        gen_base = generated.variants.get("FLXC1000")
        ref_base = reference.variants.get("FLXC1000")

        assert gen_base is not None, "Generated MDD missing FLXC1000 base variant"
        assert ref_base is not None, "Reference MDD missing FLXC1000 base variant"

        missing = ref_base.services - gen_base.services
        extra = gen_base.services - ref_base.services

        assert (
            not missing
        ), f"Missing services in FLXC1000 base variant: {sorted(missing)}"
        assert not extra, f"Extra services in FLXC1000 base variant: {sorted(extra)}"
        assert (
            gen_base.services == ref_base.services
        ), "Base variant services must be exactly equal"

    def test_boot_variant_services_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """Boot_Variant must have exactly the same services (SecurityAccess)."""
        gen_boot = generated.variants.get("FLXC1000_Boot_Variant")
        ref_boot = reference.variants.get("FLXC1000_Boot_Variant")

        assert gen_boot is not None, "Generated MDD missing Boot_Variant"
        assert ref_boot is not None, "Reference MDD missing Boot_Variant"

        missing = ref_boot.services - gen_boot.services
        extra = gen_boot.services - ref_boot.services

        assert not missing, f"Missing services in Boot_Variant: {sorted(missing)}"
        assert not extra, f"Extra services in Boot_Variant: {sorted(extra)}"
        assert (
            gen_boot.services == ref_boot.services
        ), "Boot_Variant services must be exactly equal"

    def test_app_variant_services_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """App_0101 variant must have exactly the same services (should inherit from parent)."""
        gen_app = generated.variants.get("FLXC1000_App_0101")
        ref_app = reference.variants.get("FLXC1000_App_0101")

        assert gen_app is not None, "Generated MDD missing App_0101 variant"
        assert ref_app is not None, "Reference MDD missing App_0101 variant"

        missing = ref_app.services - gen_app.services
        extra = gen_app.services - ref_app.services

        assert not missing, f"Missing services in App_0101: {sorted(missing)}"
        assert not extra, f"Extra services in App_0101: {sorted(extra)}"

    def test_parent_refs_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """Each variant must have exactly the same number of parent refs.

        Expected parentRefs in golden FLXC1000.mdd:
        - FLXC1000 (base): 2 Protocol refs (UDS_Ethernet_DoIP, UDS_Ethernet_DoIP_DOBT)
        - FLXC1000_Boot_Variant: 1 Variant ref (FLXC1000)
        - FLXC1000_App_0101: 1 Variant ref (FLXC1000)
        """
        errors = []
        for variant_name, ref_variant in reference.variants.items():
            gen_variant = generated.variants.get(variant_name)
            if gen_variant is None:
                errors.append(f"  {variant_name}: missing in generated")
            elif gen_variant.parent_ref_count != ref_variant.parent_ref_count:
                errors.append(
                    f"  {variant_name}: {gen_variant.parent_ref_count} parent_refs "
                    f"(expected {ref_variant.parent_ref_count})"
                )

        assert not errors, "Parent ref count mismatch per variant:\n" + "\n".join(
            errors
        )

    def test_comparams_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """ComParams must be exactly the same - no more, no less.

        Expected ComParams in golden FLXC1000.mdd:
        - CP_DoIPLogicalGatewayAddress: 4096 (0x1000)
        - CP_DoIPLogicalFunctionalAddress: 65535 (0xFFFF)
        - CP_UniqueRespIdTable: complex value with ECU address
        """
        gen_names = set(generated.comparams.keys())
        ref_names = set(reference.comparams.keys())

        missing = ref_names - gen_names
        extra = gen_names - ref_names

        assert not missing, f"Missing ComParams in generated: {sorted(missing)}"
        assert not extra, f"Extra ComParams in generated: {sorted(extra)}"

        # Also verify values match for common params
        for name in gen_names & ref_names:
            gen_val = generated.comparams[name]
            ref_val = reference.comparams[name]
            # Skip complex values (like CP_UniqueRespIdTable which may be None)
            if gen_val is not None and ref_val is not None:
                assert gen_val == ref_val, (
                    f"ComParam {name} value mismatch: "
                    f"generated={gen_val}, reference={ref_val}"
                )


class TestFLXCNG1000ExactComparison:
    """EXACT comparison tests for FLXCNG1000 ECU."""

    @pytest.fixture
    def yaml_path(self) -> Path:
        """Source YAML file for FLXCNG1000."""
        yaml_path = GOLDEN_DIR / "FLXCNG1000_yaml.yaml"
        if not yaml_path.exists():
            pytest.skip(f"YAML file not found: {yaml_path}")
        return yaml_path

    @pytest.fixture
    def reference_path(self) -> Path:
        """Reference MDD from ODX (generated by odxtools)."""
        mdd_path = GOLDEN_DIR / "FLXCNG1000.mdd"
        if not mdd_path.exists():
            pytest.skip(f"Reference MDD not found: {mdd_path}")
        return mdd_path

    @pytest.fixture
    def generated_path(self, yaml_path: Path, tmp_path: Path) -> Path:
        """Convert YAML to MDD and return path to generated file."""
        output_path = tmp_path / "FLXCNG1000_generated.mdd"
        convert_yaml_to_mdd(yaml_path, output_path)
        return output_path

    @pytest.fixture
    def generated(self, generated_path: Path) -> MDDContent:
        """Parse generated MDD content."""
        return load_mdd_content(generated_path)

    @pytest.fixture
    def reference(self, reference_path: Path) -> MDDContent:
        """Parse reference MDD content."""
        return load_mdd_content(reference_path)

    def test_ecu_name_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """ECU name must be exactly equal."""
        assert (
            generated.ecu_name == reference.ecu_name
        ), f"ECU name mismatch: '{generated.ecu_name}' vs '{reference.ecu_name}'"

    def test_variant_names_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """Variant names must be exactly the same set."""
        gen_names = set(generated.variants.keys())
        ref_names = set(reference.variants.keys())

        missing = ref_names - gen_names
        extra = gen_names - ref_names

        assert not missing, f"Missing variants: {sorted(missing)}"
        assert not extra, f"Extra variants: {sorted(extra)}"

    def test_all_services_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """Total service set must be exactly equal."""
        missing = reference.all_services - generated.all_services
        extra = generated.all_services - reference.all_services

        assert not missing, f"Missing services: {sorted(missing)}"
        assert not extra, f"Extra services: {sorted(extra)}"

    def test_comparams_exact_match(
        self, generated: MDDContent, reference: MDDContent
    ) -> None:
        """ComParams must be exactly the same - no more, no less."""
        gen_names = set(generated.comparams.keys())
        ref_names = set(reference.comparams.keys())

        missing = ref_names - gen_names
        extra = gen_names - ref_names

        assert not missing, f"Missing ComParams in generated: {sorted(missing)}"
        assert not extra, f"Extra ComParams in generated: {sorted(extra)}"


class TestMDDReaderBasics:
    """Basic tests for MDD reader functionality."""

    def test_reader_can_parse_reference_flxc1000(self, mdd_reader) -> None:
        """Should parse reference FLXC1000.mdd without errors."""
        mdd_path = GOLDEN_DIR / "FLXC1000.mdd"
        if not mdd_path.exists():
            pytest.skip(f"Reference MDD not found: {mdd_path}")

        structure = mdd_reader.read_structure(mdd_path)
        assert structure is not None
        assert structure.ecu_name is not None

    def test_reader_can_parse_reference_flxcng1000(self, mdd_reader) -> None:
        """Should parse reference FLXCNG1000.mdd without errors."""
        mdd_path = GOLDEN_DIR / "FLXCNG1000.mdd"
        if not mdd_path.exists():
            pytest.skip(f"Reference MDD not found: {mdd_path}")

        structure = mdd_reader.read_structure(mdd_path)
        assert structure is not None
        assert structure.ecu_name is not None

    def test_reader_rejects_invalid_file(self, mdd_reader, tmp_path: Path) -> None:
        """Should reject files without valid MDD magic header."""
        invalid_file = tmp_path / "invalid.mdd"
        invalid_file.write_bytes(b"not a valid mdd file")

        with pytest.raises(ValueError, match="Invalid MDD file.*magic header"):
            mdd_reader.read_structure(invalid_file)


class TestGoldenFilesIntegrity:
    """Tests to verify golden test files are properly set up."""

    def test_golden_directory_exists(self) -> None:
        """Golden directory should exist."""
        assert GOLDEN_DIR.exists(), f"Golden directory not found: {GOLDEN_DIR}"

    def test_flxc1000_yaml_exists(self) -> None:
        """FLXC1000 YAML should exist in golden directory."""
        yaml_path = GOLDEN_DIR / "FLXC1000_yaml.yaml"
        assert yaml_path.exists(), f"FLXC1000 YAML not found: {yaml_path}"

    def test_flxc1000_mdd_exists(self) -> None:
        """FLXC1000 reference MDD should exist in golden directory."""
        mdd_path = GOLDEN_DIR / "FLXC1000.mdd"
        assert mdd_path.exists(), f"FLXC1000 MDD not found: {mdd_path}"

    def test_flxcng1000_yaml_exists(self) -> None:
        """FLXCNG1000 YAML should exist in golden directory."""
        yaml_path = GOLDEN_DIR / "FLXCNG1000_yaml.yaml"
        assert yaml_path.exists(), f"FLXCNG1000 YAML not found: {yaml_path}"

    def test_flxcng1000_mdd_exists(self) -> None:
        """FLXCNG1000 reference MDD should exist in golden directory."""
        mdd_path = GOLDEN_DIR / "FLXCNG1000.mdd"
        assert mdd_path.exists(), f"FLXCNG1000 MDD not found: {mdd_path}"

    def test_readme_exists(self) -> None:
        """README should exist in golden directory."""
        readme_path = GOLDEN_DIR / "README.md"
        assert readme_path.exists(), f"README not found: {readme_path}"
